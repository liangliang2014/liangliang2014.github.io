---
title: JavsScript 入门（4）：函数调用栈
date: 2024-03-28
categories: programming
tags: 
- javascript
- syntax
- function
- call-stack
---

### 函数定义

```javascript
function f(x) {
  ...
}
```

- 定义了一个名字为 `f` 的 **函数**，函数 `f` 的 **形参** 名字为 `x`
- `{ ... }` 花括号包围的部分，是函数 `f` 的 **函数体**

### 函数的返回值

```javascript
function f(x) {
  ...
  return 1
}
```

- 函数使用 `return` 语句 **返回值**
- 如果函数体中写了 `return 1` 语句，那么函数的返回值，就是 `return` 后面的值 `1`
- 如果函数体中没有写 `return`，或者 `return` 后面没有值，那就是 `return undefined`

```javascript
function f(x) {
  ...
  // return undefined
}
```

```javascript
function f(x) {
  return  // return undefined
}
```

### 函数的调用和返回

```javascript
function f(x) {
  ...
  return 1
}
...
let b = f(0)
...
```

- 首先定义了一个函数 `f`
- ...
- 执行 `let b = f(0)`。`f(0)` 调用函数 `f`，程序会记住这个 **位置** `let b = f(0)`
  - 程序会 跳转到 `f` 的函数体中，形参 `x` 被赋值为实参 `0`（相当于 进入了一个 **房间**，房间里已经有了 `let x = 0`）
  - ...
  - `return 1` 表明函数 `f` 返回了，返回值是 `1`
- 程序 从 **房间** 里退出，回到记住的 **位置** `let b = f(0)`，接着向下执行
- 变量 `b` 被赋值为 `f(0)` 的返回值 `1`
- ...

### 一个函数调用多次

```javascript
function f(x) {
  ...
  return x
}
...
let b1 = f(1)
...
let b2 = f(2)
...
```

- 首先定义了一个函数 `f`
- ...
- 执行 `let b1 = f(1)`。`f(1)` 调用函数 `f`，程序会记住这个 **位置** `let b1 = f(1)`
  - 程序会 跳转到 `f` 的函数体中，形参 `x` 被赋值为实参 `1`（进入一个 **房间**，房间里已经有了 `let x = 1`）
  - ...
  - `return x` 表明函数 `f` 返回了，返回值是 `x`，值为 `1`
- 程序 从 **房间** 里退出，回到记住的 **位置** `let b1 = f(1)`，接着向下执行
- 变量 `b1` 被赋值为 `f(1)` 的返回值 `1`
- ...
- 执行 `let b2 = f(2)`。`f(2)` 调用函数 `f`，程序会记住这个 **位置** `let b2 = f(2)`
  - 程序会 跳转到 `f` 的函数体中，形参 `x` 被赋值为实参 `2`（进入一个 **房间**，房间里已经有了 `let x = 2`）
  - ...
  - `return x` 表明函数 `f` 返回了，返回值是 `x`，值为 `2`
- 程序 从 **房间** 里退出，回到记住的 **位置** `let b2 = f(2)`，接着向下执行
- 变量 `b2` 被赋值为 `f(2)` 的返回值 `2`
- ...

### 一个函数有多个参数

```javascript
function f(x, y) {
  ...
  return 1;
}
...
let b = f(0, 1)
...
```

- 函数可以接受多个参数 `x`，`y`，函数调用时，可以传入多个实参 `0`，`1`
- `f(0,1)` 调用时，形参 `x` 被赋值为 `0`，形参 `y` 被赋值为 `1`（进入一个房间，房间里已经有了 `let x=0,y=1`）

### 一个函数调用另一个函数

```javascript
function f(x) {
  ...
  let b = g(2)
  ...
  return x
}
function g(y) {
  ...
  return y
}
...
let k = f(1)
...
```

- 首先 定义了两个函数 `f` 和 `g`
- ...
- 执行 `let k = f(1)`。`f(1)` 调用 `f`，实参为 `1`，记住这个 **位置1** `let k = f(1)`
  - 程序会 跳转到了 `f` 的函数体中，形参 `x` 被赋值为实参 `1`（进入一个 **房间1**，房间里已经有了 `let x=1`）
  - ...
  - 执行`let b = g(2)`。`g(2)` 调用了函数 `g`，记住这个 **位置2** `let b = g(2)`
    - 跳转到 `g` 的函数体中，的形参 `y` 被赋值为实参 `2`（进入一个 **房间2**，房间里已经有了 `let y=2`）
    - ...
    - `g` 中的 `return y` 表明了函数 `g` 返回了，返回值是 `y`，值为 `2`
  - 程序 从 **房间2** 退出，回到 **房间1** 中的 **位置2** `let b = g(1)`，接着向下执行
  - 变量 `b` 被赋值为 `g(1)` 的返回值 `2`
  - 接着执行 函数 `f` 的函数体
  - ...
  - `return 2` 表明 `f` 返回了，返回值是 `x`，值为 `1`
- 程序 从 **房间1** 退出，回到 **位置1** `let k = f(1)`，接着向下执行
- 变量 `k` 被赋值为 `f(1)` 的返回值 `1`
- ...

### 函数调用自己

```javascript
function f(x) {
  if (x == 2) {
    return x
  }
  let c = f(x + 1)
  return x
}
...
let b = f(1)
...
```

- 首先定义了一个函数 `f`，形参为 `x`
- ...
-  执行 `let b = f(1)`。`f(1)` 调用了 `f`，实参为 `1`，程序会记住这个 **位置1** `let b = f(1)`
  - 程序会 跳转到 `f` 的函数体中，形参 `x` 被赋值为实参 `1`（进入一个 **房间1**，房间里已经有了 `let x=1`）
  - 执行 `let c = f(x + 1)`。`f(x+1)` **又** 调用了 `f`，程序会记住这个 **位置2** `let c = f(x + 1)`，即 `f(2)`
    - 程序会 跳转到一个 **新的** `f` 中，形参 `x` 被赋值为 `2`（进入一个新的 **房间2**，房间里已经有了 `let x=2`）
    - `if (x == 2)` 判断符合条件，执行`return x`，表明 `f` 返回了，返回值是 `x`，值为 `2`
  - 程序 从 **房间2** 退出，回到 **房间1** 中的 **位置2** `let c = f(x + 1)`，接着向下执行
  - `return x`，表明函数 `f` 返回了，返回值是 `x`，值为 `1`
- 程序 从 **房间1** 退出，回到 **位置1** `let b = f(1)`，接着向下执行
- ...

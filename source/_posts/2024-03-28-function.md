---
title: 函数的调用栈
date: 2024-03-28
tags: 
- JavaScript
- call stack
---

我学了函数的调用栈。

### 函数的定义与调用

#### 函数定义

```javascript
function f(x){
  console.log(1)
  return 2
}
```

定义了一个名字为 `f` 的 **函数**，函数 `f` 的 **形参** 名字为 `x`

#### 函数调用

```javascript
let b = f(0)
```

对名字为 `f` 的函数进行了调用，本次调用的 **实参** 为 `0`。
还定义了一个变量 `b`，它用来接收本次 `f(0)` 调用的 **返回值**。

#### 函数的返回值

```javascript
function f(x){
  return 1
}
let b = f(0)
```

如果函数体中写了 `return` 语句，那么函数的返回值，就是 `return` 后面的值。
如果函数体中没有写 `return`，或者 `return` 后面没有值，就是 `return undefined`。

```javascript
function f(x){
}
let b = f(0)  // undefined
```

```javascript
function f(x){
  return
}
let b = f(0)  // undefined
```

#### 程序跳转

使用 `f(0)` 调用函数 `f`，程序会跳转到 `f` 的 **函数体** 中，并且 **形参** `x` 被赋值为 **实参** `0`。
函数执行完后，`return 2` 会跳会函数被调用的位置 `let b = <这里>`，然后 `b` 被赋值为函数的返回值 `2`

#### 多次调用

```javascript
function f(x){
  console.log(1)
  return 2
}

let b1 = f(0)
let b2 = f(1)
```

对函数 `f` 进行了两次调用 `f(0)` 和 `f(1)`，实参不一样，分别为 `0` 和 `1`
先执行 `f(0)`，形参 `x` 被赋值为 `0`，`return 2` 函数返回后 `b1` 被赋值为 `2`
然后在执行 `f(1)`，形参 `x` 被赋值为 `1`，`return 2` 函数返回后 `b1` 被赋值为 `2`

#### 多个参数

```javascript
function f(x,y){
  return 1;
}

let b = f(0,1)
```

函数可以接受多个参数 `x`，`y`，函数调用时，可以传入多个实参 `0`，`1`
`f(0,1)` 调用时，形参 `x` 被赋值为 `0`，形参 `y` 被赋值为 `1`

### 函数中调用另外一个函数

#### 记住位置，到新的房间，然后回到原来的位置

```javascript
function f(x){
  console.log(1)
  let b = g(2)
  return 3
}
function g(y){
  console.log(4)
  return 5
}
let k = f(0)
```

首先定义了两个函数 `f` 和 `g`，然后 `f(0)` 调用 `f`，实参为 `0`
程序跳转到了 `f` 的函数体中，形参 `x` 被赋值为本地调用的实参 `0`

在函数 `f` 的函数体中，又用 `g(2)` 调用了函数 `g`
所以程序会 **记住这个位置**，并跳转到 `g` 的函数体（相当于进入了一个新房间），`g` 的形参 `y` 被赋值为 `2`

`g` 中的 `return 5` 表明了函数 `g` 返回了（退出这个新房间，**回到原来记住的位置**）
程序会回到调用 `g` 的 `g(2)` 位置，即 `let b = <这里>`，然后 `b` 被赋值成了返回值 `5`
然后 **继续** 执行 `f` 函数体中，剩下的事情

接着 `return 3` 表明 `f` 返回了，回到了 `f` 被调用的位置 `let k = <这里>`
最后 `b` 被赋值成了返回值 `3`

#### 函数调用自己

```javascript
function f(x){
  if(x==1){
    return
  }
  f(x+1)
  console.log(x+2)
}

f(0)
```

函数可以调用自己，相当于进入了一个跟现在 **长的一样** 的新房间。

一开始函数 `f(0)` 调用，`x` 被赋值为了 `0`（记为 **房间 `0`**）
接着在函数 `f` 的函数体中，又调用了 `f(x+1)`，相当于 `f(1)` 调用
程序会 **记住这个位置** `f(x+1)`，然后进入到另外一个跟现在的 `f` 一样的函数体中，只不过 `x` 被赋值为 `1`（记为 **房间 `1`**）

在这个 **新房间 `1`** 中，判断 `x==1` 就返回了，回到了刚才记住的位置 `f(x+1)` 处（**房间 `0`**），接着向下执行 `console.log(x+2)`
此时这个房间中 `x` 的值为 `0`，所以 `console.log(x+2)` 会打印 `2`

最后房间 `0` 返回了，回到了 `f(0)` 调用处，接着向下执行

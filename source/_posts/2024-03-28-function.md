---
title: 函数的调用栈
date: 2024-03-28
tags: 
- JavaScript
- call stack
---

我学了函数的调用栈。

### 函数定义

```javascript
function f(x){
  ...
}
```

- 定义了一个名字为 `f` 的 **函数**，函数 `f` 的 **形参** 名字为 `x`

### 函数的返回值

```javascript
function f(x){
  ...
  return 1
}
```

- 如果函数体中写了 `return 1` 语句，那么函数的返回值，就是 `return` 后面的值 `1`
- 如果函数体中没有写 `return`，或者 `return` 后面没有值，就是 `return undefined`

```javascript
function f(x){
  ...
  // return undefined
}
```

```javascript
function f(x){
  return  // return undefined
}
```

### 函数的调用和返回

```javascript
function f(x){
  ...
  return 1
}
let b = f(0)
```

- 首先定义了一个函数 `f`
- `let b = f(0)`，`f(0)` 调用函数 `f`，程序会记住这个 **位置** `let b = f(0)`
  - 跳转到 `f` 的 **函数体** 中，**形参** `x` 被赋值为 **实参** `0`
  - `return 1` 表明函数 `f` 返回了，返回值是 `1`
- 程序回到记住的 **位置** `let b = f(0)` 接着向下执行
- 变量 `b` 被赋值为 `f(0)` 的返回值 `1`

### 多次调用

```javascript
function f(x){
  ...
  return 1
}

let b1 = f(0)
let b2 = f(1)
```

- 对函数 `f` 进行了两次调用 `f(0)` 和 `f(1)`。实参不一样，分别为 `0` 和 `1`
- 先执行 `let b1 = f(0)`，形参 `x` 被赋值为 `0`，函数返回后 `b1` 被赋值为函数的返回值 `1`
- 然后再执行 `let b2 = f(1)`，形参 `x` 被赋值为 `1`，函数返回后 `b1` 被赋值为函数的返回值 `1`

### 多个参数

```javascript
function f(x,y){
  ...
  return 1;
}

let b = f(0,1)
```

- 函数可以接受多个参数 `x`，`y`，函数调用时，可以传入多个实参 `0`，`1`
- `f(0,1)` 调用时，形参 `x` 被赋值为 `0`，形参 `y` 被赋值为 `1`

### 多个位置

```javascript
function f(x){
  ...
  let b = g(1)
  return 2
}
function g(y){
  ...
  return 3
}
let k = f(0)
```

- 首先定义了两个函数 `f` 和 `g`
- 然后 `f(0)` 调用 `f`，实参为 `0`，记住这个 **位置1** `let k = f(0)`
  - 程序跳转到了 `f` 的函数体中，形参 `x` 被赋值为 `0`
  - 在函数 `f` 的函数体中，`g(1)` 调用了函数 `g`，再记住这个 **位置2** `let b = g(1)`
    - 跳转到 `g` 的函数体，`g` 的形参 `y` 被赋值为 `1`
    - `g` 中的 `return 3` 表明了函数 `g` 返回了
  - 程序回到 **位置2**，即 `let b = g(1)`，`b` 被赋值成了返回值 `3`
  - `f` 从 **位置2** 开始接着向下执行
  - `return 2` 表明 `f` 返回了
- 程序回到 **位置1**，即 `let k = f(0)`，`k` 被赋值成了返回值 `2`

### 函数调用自己

```javascript
function f(x){
  if(x==2){
    return
  }
  f(x+1)
  console.log(x+2)
}

f(1)
```

- 首先定义了一个函数 `f`，形参为 `x`
- `f(1)` 调用了 `f`，实参为 `1`，程序会记住这个 **位置1** `f(1)`
  - 程序跳转到了 `f` 的函数体中，形参 `x` 被赋值为 `1`（记为 **房间1**）
  - 在函数 `f` 的函数体中，`f(x+1)` **又调用了** `f`，程序会记住这个 **位置2** `f(x+1)`，即 `f(2)`
    - 跳转到一个新的 `f` 中（到了长的一样新房间，记为 **房间2**），形参 `x` 被赋值为 `2`
    - `if(x==1)` 判断符合条件，`return` 表示这个新房间 `f` 返回了
  - 程序回到 **位置2** `f(x+1)`，接着向下执行
  - `console.log(x+2)` 此时这个房间中 `x` 的值为 `1`，所以打印 `x+2`，即为 `3`
  - 接着函数体执行完了，没有返回值，相当于 `return undefined`，函数返回了
- 程序回到了 **位置1** `f(1)`
- 接着向下执行
